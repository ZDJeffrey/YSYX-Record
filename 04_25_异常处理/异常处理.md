# 异常处理

## 异常号的保存
> x86通过软件来保存异常号, 没有类似cause的寄存器. mips32和riscv32也可以这样吗? 为什么?

不可以，x86是因为需要使用异常号根据IDT来找到对应的异常处理函数，而riscv32则是直接跳转到mtvec寄存器中的地址，需要根据寄存器中的值来判断对应的异常号从而采取对应的措施，因此不能使用软件来保存异常号。

## 对比异常处理与函数调用
> 我们知道进行函数调用的时候也需要保存调用者的状态: 返回地址, 以及calling convention中需要调用者保存的寄存器. 而CTE在保存上下文的时候却要保存更多的信息. 尝试对比它们, 并思考两者保存信息不同是什么原因造成的.

相比于函数调用，异常处理是上下文无关的(CSR除外)，因此需要将原本程序的状态机完整地保存下来。而函数调用是需要有参数和返回值的，因此只需要根据ABI保存部分寄存器(调用者状态)。

## 诡异的x86代码
> x86的trap.S中有一行pushl %esp的代码, 乍看之下其行为十分诡异. 你能结合前后的代码理解它的行为吗? Hint: 程序是个状态机.

因为esp也是状态机所处状态的一部分，因此也需要将esp的值保存下来作为参数传递给`__am_irq_handle`函数进行处理

## 理解上下文结构体的前世今生
> 你会在__am_irq_handle()中看到有一个上下文结构指针c, c指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? $ISA-nemu.h, trap.S, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?

在`__am_asm_trap`中，会将上下文结构中的内容压入栈中，然后通过`mv a0, sp`将栈顶指针作为参数传递给函数`__am_irq_handle`中，从而得到上下文结构体指针c。
讲义是抽象地描述了自陷的过程，`$ISA-nemu.h`则根据特定的ISA实现了上下文结构体，`trap.S`实现了上下文结构体的赋值，`trap.S`则包含了`NEMU`实现的新指令，从而得以运行。

## 从加4操作看CISC和RISC
> 事实上, 自陷只是其中一种异常类型. 有一种故障类异常, 它们返回的PC和触发异常的PC是同一个, 例如缺页异常, 在系统将故障排除后, 将会重新执行相同的指令进行重试, 因此异常返回的PC无需加4. 所以根据异常类型的不同, 有时候需要加4, 有时候则不需要加.
> 这时候, 我们就可以考虑这样的一个问题了: 决定要不要加4的, 是硬件还是软件呢? CISC和RISC的做法正好相反, CISC都交给硬件来做, 而RISC则交给软件来做. 思考一下, 这两种方案各有什么取舍? 你认为哪种更合理呢? 为什么?

在硬件层面判断加4操作可以简化软件的设计，但是在硬件设计时就需要设定对应异常类型是否进行加4操作，增加硬件的复杂度且使得软件无法灵活设计。
在软件层面判断加4操作可以使得硬件设计更加简单，且可以根据软件所需灵活设计，但是会增加软件的复杂度，降低执行效率。

## 理解穿越时空的旅程
> 从yield test调用yield()开始, 到从yield()返回的期间, 这一趟旅程具体经历了什么? 软(AM, yield test)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码/C代码的行为, 尤其是一些比较关键的指令/变量.

- `yield`执行`ecall`
- `NEMU`执行`ecall`时调用函数`isa_raise_intr`设置`mepc`和`mstatus`，并设置跳转指令为`mtvec`寄存器内容
- 跳转到`__am_asm_trap`，首先将上下文信息压入栈中，将栈顶指针作为上下文结构体的指针以参数形式传递给`__am_irq_handle`函数
- `__am_irq_handle`函数根据上下文结构体中的信息设置事件，并根据具体的事件判断是否需要将`mepc`内容设置为触发异常的下一条指令，然后调用`cte_init`注册得到的`user_handle`，即`simple_trap`。
- `simple_trap`根据事件打印相应的字符并返回
- `simple_trap`返回后，`__am_irq_handle`也返回
- `__am_asm_trap`将栈中的上下文信息弹出，恢复状态机状态
- 最后`NEMU`执行`mret`，设置`pc`跳转至`mepc`中的地址



