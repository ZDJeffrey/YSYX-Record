# PA1

## `static`关键字
框架代码中使用`static`关键字定义`wp_pool`等变量，可以限制变量的作用域，使其只在当前文件中有效，从而可以避免在不同模块中因为变量名冲突而引发的问题，也可以限制外部模块只能通过特定的接口访问这些变量，提高代码的安全性。

## 段错误
段错误是因为对无效内存进行访问，通过对NULL进行访存编写一个简单的程序，可以触发段错误。

```c
#include <stdio.h>
int main(){
  int *p = NULL;
  *p = 1;
  return 0;
}
```
使用gdb调试这个程序，在发生段错误时，gdb会输出发生段错误时接收到的信号和发生段错误的指令地址及其对应的源代码位置。
通过上述信息，虽然无法直接定位到在何处产生了野指针，但是可以定位是哪个变量存储无效内存地址导致的段错误，从而可以通过检查代码找到问题所在。

## Address Sanitizer
在gcc中开启-fsanitize=address选项可以开启Address Sanitizer，可以检测内存访问错误，从而检测段错误。
Address Sanitizer会对程序的内存进行追踪，记录内存的分配和释放情况，同时通过在程序中内存访问前插入检查代码(插桩)，检查用于访问内存的地址是否有效，从而检测内存访问错误。
通过上述机制，Address Sanitizer不仅可以检测地址越界，还可以检查涉及动态内存的use-after-free问题。
此外，通过添加`-g`选项添加调试信息，还可以再Address Sanitizer检测到内存访问错误时，输出错误发生的源代码位置。

## 断点
目前`nemu`中使用监视点实现断点功能，即`w $pc==ADDR`，会在每执行一条指令后就检查一次`pc`寄存器的值是否等于`ADDR`，这会导致运行效率降低。
在x86中，使用`int3`实现软件中断，从而在硬件层面实现断点的检测，可以考虑类似的方法来实现断点功能，从而提高运行效率。
在`gdb`中通过将指令的第一个字节替换为`0xcc`来实现断点，当执行到断点时，会触发一个中断，从而停止程序的执行，`gdb`同时通过保存被替换的字节，使得原指令能够正常执行。
若`int3`的长度大于1个字节，由于x86是变长指令集，若需要设置断点的指令只有一个字节，则在替换成`int3`时会覆盖其他的指令，导致其他指令无法正常执行。因此`int3`的长度要保证是指令的最小长度。
在设置断点时，若不在指令的首字节设置断点，会导致处理器无法识别到`int3`指令，从而导致无法进行软件中断而停止程序，并且会因为无法检测到`int3`而导致原指令按照被替换后的指令执行，导致执行结果错误。

## 模拟器与调试器
模拟器提供了模拟的硬件环境，而调试器则是基于底层的硬件环境进行调试。
与NEMU相比，GDB并不维护寄存器等硬件状态，而是与底层硬件通过交互来获取硬件状态。

## 目录定位问题
> 假设你现在需要了解一个叫selector的概念, 请通过i386手册的目录确定你需要阅读手册中的哪些地方. 即使你选择的ISA并不是x86, 也可以尝试去查阅这个概念.

2.5 Operand Selection


## 程序是个状态机
> 画出计算1+2+...+100的程序的状态机

使用状态机描述上述程序运行过程
```
(0,x,x)->(1,0,x)->(2,0,0)->               //初始化
(3,0,1)->(4,1,1)->(2,1,1)->               //第一次循环
(3,1,2)->(4,3,2)->(2,3,2)->               //第二次循环
...
(3,4853,99)->(4,4951,99)->(2,4951,99)->   //第99次循环
(3,4951,100)->(4,4951,100)->              //第100次循环
(5,4951,100)->(5,4951,100)->...           //死循环
```
## 理解基础设施
> 首先作以下假设:
> - 假设你需要编译500次NEMU才能完成PA.
> - 假设这500次编译当中, 有90%的次数是用于调试.
> - 假设你没有实现简易调试器, 只能通过GDB对运行在NEMU上的客户程序进行调试. 在每一次调试中, 由于GDB不能直接观测客户程序, 你需要花费30秒的时间来从GDB中获取并分析一个信息.
> - 假设你需要获取并分析20个信息才能排除一个bug.
> 那么这个学期下来, 你将会在调试上花费多少时间?
> 由于简易调试器可以直接观测客户程序, 假设通过简易调试器只需要花费10秒的时间从中获取并分析相同的信息. 那么这个学期下来, 简易调试器可以帮助你节省多少调试的时间?

总共会有450次调试，每次调试需要花费20\*30=600s=10min，则总共需要花费4500min=75h。
使用简易调试器，每次调试需要花费20\*10=200s=3min20s，总共需要花费25h，因此可以节省50h的调试时间

## RTFM
> 理解了科学查阅手册的方法之后, 请你尝试在你选择的ISA手册中查阅以下问题所在的位置。
> - riscv32
>   - riscv32有哪几种指令格式?
>   - LUI指令的行为是什么?
>   - mstatus寄存器的结构是怎么样的?

1. 非特权指令集手册:2.2. Base Instruction Formats
2. 非特权指令集手册:2.4.1. Integer Register-Immediate Instructions
3. 特权指令集手册:3.1.6
Machine Status Registers (mstatus and mstatush)

## shell命令
> 完成PA1的内容之后, `nemu/`目录下的所有.c和.h和文件总共有多少行代码? 你是使用什么命令得到这个结果的? 和框架代码相比, 你在PA1中编写了多少行代码? (Hint: 目前`pa0`分支中记录的正好是做PA1之前的状态, 思考一下应该如何回到"过去"?) 你可以把这条命令写入`Makefile`中, 随着实验进度的推进, 你可以很方便地统计工程的代码行数, 例如敲入`make count`就会自动运行统计代码行数的命令. 再来个难一点的, 除去空行之外, `nemu/`目录下的所有.c和.h文件总共有多少行代码?

- 计算当前目录下所有.c和.h文件的总行数
```shell
find . -name "*.[ch]" | xargs cat | wc -l
```
- 对比pa0分支和当前分支的代码行数
使用`git checkout`切换至pa0分支，再次使用上述命令计算代码行数。
pa0代码行数为23780，当前分支的代码行数为24382。
- 计算当前目录下所有.c和.h文件的总行数(不包括空行)
```shell
find . -name "*.[ch]" | xargs cat | grep -v "^$" | wc -l
```

## RTFM
> 打开`nemu/scripters/build.mk`文件, 你会在`CFLAGS`变量中看到gcc的一些编译选项. 请解释gcc中的`-Wall`和`-Werror`有什么作用? 为什么要使用`-Wall`和`-Werror`?

- `-Wall`：开启所有警告信息，发现潜在的问题，提高代码质量。
- `-Werror`：将所有的警告视为错误，使得编译器在发现警告时会报错，从而保证代码的质量。

使用这两个选项能够在编译时让编译器尽可能检查代码中存在的潜在问题，并且在发现问题时报错，能够减少运行时的错误，提高代码的质量。

