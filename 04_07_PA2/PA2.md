# PA2

## 理解YEMU如何执行程序
### 画出在YEMU上执行的加法程序的状态机
格式:(pc,r0,r1)
```
(0,x,x)->(1,33,x)->(2,33,33)->(3,16,33)->(4,49,33)->(5,49,33)->(6,98,33)
```
由于x=16的存储单元为`0b0001000`，对应的op段并非无效指令，因此也会执行，对应`R[0]<-R[0]+R[2]`

### 通过RTFSC理解YEMU如何执行一条指令
YEMU的IF阶段根据pc寄存器的值从内存M对应位置读取指令，根据指令的高四位op判断指令类型。ID阶段根据指令的类型进行译码得到执行指令所需的寄存器、内存地址等。最后EX阶段根据具体的指令使用译码得到的寄存器、内存地址等进行计算。执行结束后，pc寄存器加1，指向下一条指令。
当识别到无效指令时，YEMU会停止执行。

### 联系
YEMU执行一条指令的过程对应了状态机中的一次状态转移。根据当前寄存器、内存等状态，YEMU执行后的状态是确定的，因此通过不同的初始内存和寄存器状态，可以得到不同的状态机。本质上就是在YEMU上运行不同的程序，满足对应程序的状态机。

## 大端与小端
> Motorola 68k系列的处理器都是大端架构的. 现在问题来了, 考虑以下两种情况:
> - 假设我们需要将NEMU运行在Motorola 68k的机器上(把NEMU的源代码编译成Motorola 68k的机器码)
> - 假设我们需要把Motorola 68k作为一个新的ISA加入到NEMU中
> 在这两种情况下, 你需要注意些什么问题? 为什么会产生这些问题? 怎么解决它们?

1. 在不考虑客户程序镜像文件读写时，直接使用程序中指定的初始指令，若将NEMU编译运行在Morola 68k的机器上，并不需要注意端序问题，端序对于C程序是透明的，CPU会根据使用的端序进行处理，使得不管在大端还是小端机器上运行，程序的。但是当需要读取客户程序镜像文件时，若文件是小端存储的，需要在客户程序内存访问(读取、写入)时进行端序转换，否则会读取或写入错误的内存内容。
2. 若在NEMU中加入Motorola 68k ISA，并且在小端机器中运行，如果仅使用程序中指定的初始指令，则无需考虑端序问题。但是读取Motoroal 68k客户程序镜像文件时，由于文件是大端存储的，在客户程序内存访问(读取、写入)时进行端序转换，否则会读取或写入错误的内存内容。

## 立即数读取
> mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样, 把C代码中的32位常数直接编码到一条指令中. 思考一下, mips32和riscv32应该如何解决这个问题?

1. 通过立即数扩展的方式，可以将立即数扩展到32位
2. 将立即数存储在程序的数据段中，通过访存指令将立即数加载到寄存器中
3. 使用移位指令，分段加载32位立即数

## 一条指令在NEMU中的执行过程
- IF
  首先根据`pc`寄存器通过`inst_fetch`函数从内存中读取指令，并设置`snpc`为`pc`+4，指向静态地下一条指令。
- ID
  在`decode_exec`函数中首先根据指令的`opcode`和`func`段进行指令的匹配，当匹配到指令后，根据指令的类型获得指令的操作数。
- EX
  根据具体的执行，对操作数实现具体的执行效果。

最后将`pc`设置为`dnpc`，指向下一条指令。若指令无需跳转，则`dnpc`等于`snpc`，否则`dnpc`为跳转后的地址。


## 未实现指令报错信息
当未实现所需执行的指令时，在ID阶段会匹配到`inv`指令，进而调用`INV(s->pc)`从而调用`invalid_inst`函数，在该函数中输出为实现指令的位置、十六进制串以及下一条指令的十六进制串，最后再输出RTFM提示信息。


## 指令名对照
> AT&T格式反汇编结果中的少量指令, 与手册中列出的指令名称不符, 如x86的cltd, mips32和riscv32则有不少伪指令(pseudo instruction). 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?

- 手册查找
  通过在手册中查找`pseudoinstruction`可查找到大部分的伪指令
- 反汇编
  通过添加选项`-M no-aliases`可以禁用伪指令，从而得到真实的指令名称

## 乘法指令
`mulh`、`mulhu`、`mulshu`中都需要使用$2\times XLEN$的源操作数进行乘法运算。对于RV32，需要扩展到64位(uint64_t/int64_t)，对于RV64，需要扩展到128位(__uint128_t/__int128_t)。
以上类型通过宏定义`dword_t`和`sdword_t`使得在不同位数的机器上都能正确运行。
```c
typedef MUXDEF(CONFIG_ISA64, __uint128_t, uint64_t) dword_t;
typedef MUXDEF(CONFIG_ISA64, __int128_t, int64_t) sdword_t;
```
当需要扩展为有符号数时，若直接将其扩展到更高的位数，会导致符号位的扩展错误，因此需要现将其扩展到相同位数的有符号数，再扩展至更高位数的有符号数。
例子如下：
```c
#include "stdio.h"
int main(){
  unsigned char i = -1;
  printf("%d\n",(int)i);
  return 0;
}
```
上述代码最终输出为255
```c
#include "stdio.h"
int main(){
  unsigned char i = -1;
  printf("%d\n",(int)(char)i);
  return 0;
}
```
上述代码最终输出为-1

