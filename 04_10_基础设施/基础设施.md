# 基础设施
## 消失的符号
符号表中的符号，是能够在程序任何地方中直接通过地址进行访问的，包括全局变量、函数。
宏定义在预编译时就会被展开，而形参与局部变量则是存储在函数栈帧中，只有在其作用于中才能够访问。

## 寻找"Hello World!"
> 在Linux下编写一个Hello World程序, 编译后通过上述方法找到ELF文件的字符串表, 你发现"Hello World!"字符串在字符串表中的什么位置? 为什么会这样?

使用`hd`查看ELF文件发现"Hello world"位于只读数据段`.rodata`中，而字符串表中存在`_IO_stdin_used`其Value为只读数据段的首地址。
在C语言程序中的字符串常量是存储在只读数据段中的，而为了访问只读数据段，需要使用一个符号来指示只读数据段的地址。
但是"Hello world"字符串放置在0x2004处，而`_IO_stdin_used`的Value为0x2000，程序需要通过偏移量来访问字符串，对应反汇编`2004 <_IO_stdin_used+0x4>`
[what-is-io-stdin-used](https://stackoverflow.com/questions/74595580/what-is-io-stdin-used)

## `JAL`和`JALR`识别函数调用和返回
在寄存器中`ra`(`x1`)存储函数的返回地址(若需要递归调用，则将其压入函数栈中)，因此通过识别`JAL`和`JALR`的`rd`是否为`ra`寄存器即可识别函数调用。
而需要进行函数返回时，通过`jalr	zero,0(ra)`指令将`ra`寄存器中的地址取出，进行函数返回，因此直接识别`jalr	zero,0(ra)`指令即可识别函数返回。

## 不匹配的函数调用和返回
通过反汇编发现当存在尾递归时，编译器通过优化使其在保留`ra`寄存器的同时直接通过`jalr	zero,0(a5)`进行跳转，在调用的函数里面直接返回当前的`ra`，因此虽然ftrace的函数调用和返回的函数名不匹配，但是函数调用和函数返回的次数是匹配的。

## 冗余的符号表
使用gcc编译后通过strip丢弃符号表
可执行文件在丢弃符号表之后可以直接运行
而可重定位文件在丢弃符号表后无法进行链接。
符号表的作用在于链接时通过符号确定函数、全局变量等地址，在可执行文件中已经确定了地址，因此不需要符号表。但在可重定位文件中，若没有符号表，则无法在链接文件时确定地址，从未无法生成可执行文件。

## 奇怪的错误码
在使用AM测试代码时若代码出错，通过`halt(code)`返回错误码，从而Makefile会获得该错误码(例如在native下通过exit(code)，nemu下通过设置a0为code后ebreak，由nemu进而返回该错误码)。
在test的Makefile中也是通过判断make的返回值是否为0来判断是否通过测试，因此若返回值不为0则会报错。

## native使用klib
在klib的C源文件中通过预编译指令`#if !defined(__ISA_NATIVE__) || defined(__NATIVE_USE_KLIB__)`来设置是否使用kilb。
若不使用时则源文件为空，程序中调用的相关函数会链接到glibc，若非空，则直接链接到klib。

## 编写可移植的程序
在涉及到32位和64位差异的时候，使用标准的`stdint.h`头文件中的类型定义，关于长度相关的定义，使用`sizeof`而非常量。
例如对于指针长度的假设，使用`sizeof`进行计算，而不是固定假设的长度。

## 函数测试
在测试`sprintf`函数时，在`native`中能通过测试，但是在`nemu`中无法通过测试。
起初认为是`nemu`存在问题(控制变量法)，但是之前的多个测试都可以通过，仅当打印`INT_MIN`时无法通过。
后续查看`sprintf`实现发现是整型转换为字符串时，将整型取绝对值的时候直接使用`int`存储，而`INT_MIN`的绝对值超出了`int`的范围。
至于在`native`中能通过测试，猜测是因为`native`中编译器对该情况进行了优化，避免了溢出。

## 通用程序
> 通用程序的性质告诉我们, NEMU的潜力是无穷的. 为了创造出一个缤纷多彩的世界, 你觉得NEMU还缺少些什么呢?

缺少连接外设功能，如显示字符、显示画面，响应中断等输入输出功能。

## 捕捉死循环
NEMU本质上是一个状态机，当前寄存器和内存表示状态，而指令则是状态转移的操作，因此如果重复进入相同状态且执行相同指令，则认为进入死循环。
记录执行过的跳转指令以及执行时的状态，如果重复执行该跳转指令，对比状态是否相同，若相同则认为进入了死循环。

