# RT-Thread

## 为什么需要使用不同的栈空间?
> 如果不同的进程共享同一个栈空间, 会发生什么呢?

如果不同的进程共享同一个栈空间，进程入栈的内容可能在进程切换后被其他进程出栈，导致进程之间的数据混乱

## riscv32的调用约定
根据ABI手册，在函数调用中`a0`-`a7`用于存储参数，`a0`-`a1`用于存储返回值.


## 危险的全局变量
> 如果使用全局变量来传递信息, 考虑以下场景, 可能会出现什么问题?
> - 在多处理器系统中, 两个处理器同时调用rt_hw_context_switch()
> - 一个线程调用rt_hw_context_switch()后写入了全局变量, 但马上到来了时钟中断, 使得系统切换到另一个线程, 但这个线程也调用了rt_hw_context_switch()

- 同时调用的话可能会导致缓存不一致，也可能导致先写入的线程的数据被后写入的线程覆盖
- 前一个线程写入全局变量的值会被后一个线程覆盖，导致切换回前一个线程时，上下文切换出错

> 如果使用全局变量来传递信息, 而代码连续调用了两次rt_hw_stack_init(), 会造成什么问题?

会导致前一个设置线程的入口函数、参数和退出函数被后一个覆盖，使得两个线程运行相同的程序

## RT-Thread运行多个AM程序
> 如果直接将多个AM程序链接到RT-Thread中, 可能会遇到什么问题? integrate-am-apps.py脚本是如何解决这些问题的? 尝试RTFSC寻找答案.

如果将多个AM程序链接到RT-Thread中，需要记录各程序的入口函数地址，同时需要确保各程序的代码段不会重叠，否则会导致程序运行出错，此外还需要为各程序合理分配栈空间。
`integrate-am-apps.py`将需要链接到RT-Thread中的AM程序的可重定向文件添加至链接源文件中，使其最终能够链接到RT-Thread中。通过修改符号表避免多个AM程序符号冲突的同时为klib函数也添加前缀，避免与stdlib冲突，同时将挂起函数统一重命名为`__rt_am_halt`。为每个AM程序生成对应的包裹函数，避免了函数参数等不适配，使其能够在RT-Thread中创建线程并运行。
